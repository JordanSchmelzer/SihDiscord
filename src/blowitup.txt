import asyncio
import logging
from discord.ext import commands
import discord
import youtube_dl
import os
# from youtubesearchpython import PlaylistsSearch
import json
from collections import deque
# from src.Tools.Check import Check
import secrets


def my_hook(d):
    if d['status'] == 'finished':
        print('Done downloading, now converting ...')


class Music:
    """A class which is assigned to each guild using the bot for Music.
    This class implements a queue and loop, which allows for different guilds to listen to different playlists
    simultaneously.
    When the bot disconnects from the Voice it's instance will be destroyed.
    """
    __slots__ = ('bot', '_guild', '_channel', '_cog', 'queue', 'next', 'current', 'np', 'volume')

    def __init__(self, bot: commands.Bot, ctx: commands.Command):
        self.bot = bot
        self._guild = ctx.guild
        self._channel = ctx.channel
        self._cog = ctx.cog

        self.queue = asyncio.Queue()
        self.next = asyncio.Event()

        self.np = None  # Now playing message
        self.volume = .5
        self.current = None

        ctx.bot.loop.create_task(self.player_loop())

    def addToQueue(self, song):
        """ Add a FFMpeg object to the queue """
        try:
            self.queue.append(song)
            self.queue.append(song)
            logging.critical('addToQueue: Queue size is: ' + str(len(self.queue)))
        except Exception as e:
            print(e)

    async def playSong(self, voice_client):
        try:
            """ pop song off the queue and play it """
            src = self.queue.popleft()
            logging.critical("I popped the current song. The queue is now this long: " + str(len(self.queue)))
            logging.critical("this means the queue is empty and the current song is about to play ")
            await voice_client.play(source=src,
                              after=lambda e:
                              print('Player error: %s' % e) if e else
                              self.playSong(voice_client)
                              )
            voice_client.source = discord.PCMVolumeTransformer(voice_client.source)
            voice_client.source.volume = 1.0
        except Exception as e:
            logging.fatal(e)

    @commands.Cog.listener()
    async def on_ready(self):
        print(f'{self} connected to discord. ready for further action')

    @commands.command()
    async def p(self, ctx: commands.Context, url: str):

        # Load options from JSON file
        with open("src/Songs/ytdl_opts.json", "r") as json_opts:
            y_opts = json.load(json_opts)

        ydl_opts = {
            'format': y_opts["format"],
            'postprocessors': [{
                'key': y_opts["key"],
                'preferredcodec': y_opts["preferredcodec"],
                'preferredquality': y_opts["preferredquality"],
            }],
            'progress_hooks': [my_hook],
            'noplaylist': True,
            'no_warnings:': True,
            'quiet': True,
        }

        # Use the options when creating a YoutubeDl object
        try:
            with youtube_dl.YoutubeDL(ydl_opts) as ydl:
                ydl.download([url])
        except Exception as e:
            logging.fatal(e)
            return

        # Generate a random token to name the song with
        token = secrets.token_hex(8)

        path = './'
        audio_source = 'src/Songs/song' + str(token) + '.mp3'
        for file in os.listdir(path):
            if file.endswith(".mp3"):
                if os.path.exists(audio_source):
                    os.remove(audio_source)
                    os.rename(path + file, audio_source)
                else:
                    os.rename(path + file, audio_source)

        # src = discord.FFmpegPCMAudio(audio_source)

        # add the downloaded file as an FFMpeg object to the queue
        self.addToQueue(discord.FFmpegPCMAudio(audio_source))
        logging.critical('there are this many songs in queue: ' + str(len(self.queue)))

        voice_channel = ctx.author.voice.channel
        voice_client = ctx.guild.voice_client
        try:
            # Check if the bot is connected to a voice channel
            if voice_client and voice_client.channel == voice_channel:
                print('')
            else:
                # Connect to the voice channel
                voice_client = await voice_channel.connect()
        except Exception as e:
            print(e)

        # check the size of the queue
        print(len(self.queue))
        while len(self.queue) > 0:
            await self.playSong(voice_client)


# The setup function below is necessary. Remember we give bot.add_cog() the name of the class in this case MembersCog.
# When we load the cog, we use the name of the file.
async def setup(bot):
    await bot.add_cog(Music(bot))
